# typeof
- typeof 可以准确的判断基础类型，但是对于对象类型就无能为力了。
```ts
typeof undefined   // undefined

typeof Function    // function
typeof null        // object
typeof []          // object
typeof {}          // object
typeof new Date()  // object

```
> 不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“ object ”。

# instanceof
- 原理是能在实例的 原型对象链 中找到该构造函数的prototype属性所指向的 原型对象，就返回true。
- 所以 instanceof 无法检测基础类型，并且所有对象类型 instanceof Object 都是 true。
```ts
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式 
	var O = R.prototype;   // 取 R 的显示原型 
	L = L.__proto__;  // 取 L 的隐式原型
	while (1) {
		if (L === null)
			return false;
		if (O === L)  // 当 O 显式原型 严格等于  L隐式原型 时，返回true
			return true;
		L = L.__proto__;
	}
}
```
# Object.prototype.toString.call()
- 除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变toString 方法的执行上下文。
```ts

export type types = 'String' | 'Number' | 'Boolean' | 'Object' | 'Undefined' | 
'Null' | 'Promise' | 'Function' | 'Date' | 'Array' | 'RegExp' | 'Error' |
 'Symbol' | 'HTMLDocument' | 'global';

// 对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。
Object.prototype.toString.call('芒果')           // "[object String]"
....

```







