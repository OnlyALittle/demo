# 渲染进程
## 主要组成线程
- GUI渲染线程
- JS引擎线程
- 事件触发线程
- 定时触发器线程
- 异步HTTP请求线程

### GUI渲染线程
- 负责渲染浏览器界面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等
- 重绘或者回流都会触发该线程执行
- GUI线程和JS引擎线程互斥，当JS引擎执行是GUI被挂起，GUI更新会保存在一个队列中，等到JS引擎空闲是立即执行

### JS引擎线程
- 负责处理js解析，运行代码，（如V8）
- 一个tab只有一个JS线程在运行
- 与GUI互斥，如果JS执行时间太长就会导致页面渲染不连贯

### 事件触发线程
- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解为，JS忙不过来，需要浏览器另开线程协助）
- 当JS引擎执行代码块如setTimeout的回调时，会将对应任务加入到事件线程中
- 当事件符合触发条件时，该线程就会把事件放到待处理队列的队尾等待JS引擎执行
- 由于JS是单线程的关系，所以处理队列得排队

### 定时触发器线程
- setTimeout、setInterval所在线程
- 浏览器的定时计数器不由JS引擎做，因此通过单线程来计时并触发定时
- W3C规定，setTimeout中低于4ms时间隔为4ms

### 异步HTTP请求线程
- XML 在链接后是通过浏览器新开一个线程请求
- 检测到状态变更时，如果有回调，将回调放入事件队列里

## 渲染过程
> 从输入 URL 到页面加载完成的过程
1. 首先做 DNS 查询(UDP)，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来
2. 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了
3. TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据
4. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件
5.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错
6.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
7.  文件解码成功后会正式开始渲染流程，
    1.  先会根据 HTML 构建 DOM 树，同时浏览器主进程负责下载CSS文件，
    2.  解析CSS文件，构建 CSSOM 树。
    3.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树
    4.  布局render树（重绘、回流），负责render树中的元素尺寸、位置等计算
    5.  绘制render树，绘制页面像素信息
    6.  浏览器调用 GPU 绘制，合成图层，将内容显示在屏幕上了
    7.  如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。
8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件

## 问题
### 为什么JS是单线程
- JS是多线程来操作这些UI DOM，则可能出现UI操作成功冲突，处于UI中的DOM节点可能成为一个临界资源
- 虽然可以通过加锁来解决，但是为了避免因为引入锁带来更大的复杂性，所以还是选择了单线程
  
### 为什么JS阻塞页面加载
- 如果两个线程同时执行，那么渲染线程前后获得的元素数据就会不一样
- 
### CSS加载会造成阻塞吗
- DOM和CSSOM通常并行构建，所以CSS加载不会阻塞DOM解析
- 但是render tree依赖它两
- 所以还是会等它完成，因此CSS加载会阻塞DOM渲染
- 因此借用上个问题，所以会阻塞JS执行

### DOMContentLoaded 与 load 的区别 ?
- `DOMContentLoaded`是DOM解析完成就执行，但是又因为CSS和DOM的解析就阻塞JS，所以
- 当没有脚本时，解析完就能触发`DOMContentLoaded`,如果有脚本，则脚本会阻塞文档解析，
- 而脚本要等CSSOM构建完成菜执行，任何情况下`DOMContentLoaded`的触发都不需要等带图片等资源加载完成
- `onload` 触发时，所有的DOM，CSS，脚本，图片等资源都加载了
- `DOMContentLoaded` -> `onload`


### 什么是CRP（关键渲染路径），怎么优化
- 关键渲染路径指浏览器将 HTML、CSS、JS转换为在屏幕上呈现的像素内容的过程
- 加快首次渲染
  - 减少资源数量
  - 减少路径长度
  - 减少大小
- 优化
  - 优化DOM
    - 删除不必要的代码和注释，减少文件大小
    - GZIP
    - HTTP缓存
  - 优化CSSOM
    - 减少、压缩
    - 媒体查询极大影响性能
  - 优化JS
    - async、defer、preload、preferch、dns-prefetch

### async、defer
- 没有时，会立即加载并执行，阻塞住渲染流程直到 JS 执行完毕
- async，异步下载，完成后执行 JS
- defer，异步下载，完成后等待所有元素解析完成后在`DOMContentLoaded`之前执行
- 异同
  - 都是异步下载
  - async下载完立即执行（就看哪个js先下载完），defer等解析完执行（按加载顺序执行）
- async不考虑依赖，比较适用于不依赖脚本会不被依赖的脚本

### preload、preferch、dns-prefetch
- preload，会把资源下载顺序权重提高，是数据提前下载，优化页面打开速度
- prefetch，预先拉取，未来啃根用到，空闲加载
- preload 必定要用到的资源，一定会加载，prefetch 可能会加载

### 回流、重绘
> 回流必定会发生重绘，重绘不一定会引发回流。
#### 回流
- 回流是布局或者几何属性需要改变就称为回流。改变 window 大小、改变字体、添加或删除样式、文字改变、定位或者浮动、盒模型也是
#### 重绘 
- 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
#### 回流所需的成本比重绘高的多
- 改变深层次的节点很可能导致父节点的一系列回流。
#### 减少重绘和回流
1. 使用 translate 替代 top
2. 使用 visibility 替换 display: none
3. DOM display: none后修改
4. 获取 offsetTop 会导致回流，因为需要去获取正确的值，所以不要放for里面
5. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
6. 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。

### 渲染层合并
- DOM元素的绘制在多个图层进行
- GPU会将所有层按照合理的顺序合并成一个图层，呈现
- 一旦渲染层提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升
  - 合成层的位图会交由GPU合成
  - 当要重绘时，只重绘自身不影响其他层

### DNS 预解析
```html
<link rel="dns-prefetch" href="//xxx.cn" />
```
